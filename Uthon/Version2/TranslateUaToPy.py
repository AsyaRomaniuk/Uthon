pykeywords = ['f_contiguous', 'isnumeric', 'ndim', 'list', 'delattr',
              'eval', '__float__', 'obj', 'pow', 'oct',
              '__rfloordiv__', '__str__', 'enumerate', 'min', 'abs',
              'swapcase', 'to_bytes', 'get', '__exit__', 'title',
              '__mod__', '__lt__', 'startswith', '__ixor__',
              'intersection', 'intersection_update', 'step',
              '__rand__', 'nbytes', 'release', 'bin', '__ceil__',
              'tuple', '__floor__', '__trunc__', 'center', 'rindex',
              'symmetric_difference', 'issuperset',
              'symmetric_difference_update', '__repr__', 'as',
              '__getattribute__', 'fromkeys', 'lambda', 'finally',
              'conjugate', 'denominator', 'ascii', 'zfill',
              '__iadd__', 'async', 'difference', 'isdisjoint',
              'compile', 'start', 'values', 'isdecimal', '__iand__',
              '__format__', 'repr', '__contains__', 'hex',
              '__rrshift__', 'sorted', '__reduce__', 'union',
              'extend', '__reversed__', 'add', '__isub__',
              '__set_format__', 'str', 'insert', 'lower',
              '__round__', 'except', 'issubclass', 'print',
              '__le__', 'clear', '__imul__', 'continue', 'format',
              'itemsize', '__int__', 'indices', 'sort', 'join',
              'suboffsets', '__pos__', '__radd__', 'numerator',
              'copy', 'set', 'slice', 'yield', 'hasattr',
              'maketrans', '__truediv__', 'remove', 'contiguous',
              '__delitem__', 'open', 'fromhex', 'Ellipsis', 'in',
              '__rlshift__', 'filter', 'isalpha', '__setattr__',
              '__lshift__', 'dict', '__rxor__', 'vars', '__new__',
              'globals', 'tolist', 'del', 'from_bytes', 'endswith',
              'getattr', 'imag', 'callable', 'round', 'real',
              'setattr', 'capitalize', '__sizeof__', 'isidentifier',
              'not', 'encode', 'input', 'casefold', '__class__',
              '__and__', 'chr', 'partition', '__subclasshook__',
              '__delattr__', 'def', 'format_map', 'bit_length',
              'exec', 'raise', '__sub__', 'bytes', 'reversed',
              'pass', 'isupper', 'len', 'isascii', 'pop', 'object',
              'if', 'locals', 'discard', 'complex', 'classmethod',
              'setdefault', 'decode', 'tobytes', 'float',
              '__invert__', 'c_contiguous', 'with', 'bytearray',
              'to_byteshex', 'islower', 'help', 'is_integer',
              'update', 'keys', '__gt__', '__abs__', 'sum', 'await',
              'True', '__pow__', 'reverse', 'map', 'lstrip', 'cast',
              'and', 'issubset', '__enter__', 'stop', '__ne__',
              '__dir__', 'is', '__divmod__', 'popitem', 'max',
              'staticmethod', '__mul__', 'from', 'class', 'replace',
              'rpartition', 'split', '__getnewargs__', 'import',
              'zip', 'toreadonly', 'strides', 'nonlocal',
              '__hash__', 'translate', 'break', 'property',
              '__ror__', 'rfind', 'ljust', '__rdivmod__', 'hash',
              'else', 'try', 'rsplit', '__ior__',
              'difference_update', 'index', 'assert', 'super',
              'expandtabs', '__alloc__', 'all', 'False', '__eq__',
              '__reduce_ex__', '__rshift__', 'any', '__bool__',
              'upper', '__getitem__', 'while', '__neg__',
              'isprintable', 'append', 'return', 'isinstance',
              '__or__', 'range', 'as_integer_ratio', 'isspace',
              '__add__', 'istitle', 'int', 'isalnum', 'rstrip',
              'strip', 'type', '__init__', '__init_subclass__',
              '__doc__', 'splitlines', 'or', 'global', 'elif', 'for',
              'items', '__iter__', '__rmul__', '__rmod__',
              '__rpow__', 'readonly', '__getformat__', 'dir',
              '__rtruediv__', '__xor__', 'isdigit', '__rsub__',
              'id', 'rjust', 'ord', 'iter', 'memoryview', '__ge__',
              'find', 'shape', 'frozenset', '__index__', '__len__',
              'bool', 'next', '__floordiv__', 'count', 'None',
              '__setitem__', 'divmod', 'ua_dir', 'breakpoint',
              '__import__', 'self', 'cout', 'outclear', "cin",
              'exit']
uakeywords = ['суміжний з фортран?', 'є цифрою?', 'ndim', 'список', 'видалити атрибут',
              'обчислити', 'в число', 'об_єкт_', 'до степеня', 'вісімковий',
              '|ціле ділення', 'в текст', 'перерахувати', 'мінімальне', 'модуль',
              'протилежний реєстр', 'в байти', 'отримати', 'вихід', 'титульний',
              'остача від ділення', 'менше?', 'починається з?', '=двійковий ксор',
              'перетин', 'зберегти перетин', 'крок',
              '|і', 'розмір в байтах', 'звільнити', 'двійковий', 'округлення до більшого',
              'кортеж', 'округлення до меншого', 'зріз до цілого', 'центрувати', 'індекс останнього',
              'симетрична різниця', 'є підмножиною?',
              'зберегти симетричну різницю', 'рядкування', 'як',
              'отримання атрибута', 'з ключів', 'лямбда', 'остаточно',
              'спряжене', 'знаменник', 'аскдіо', 'заповнити нулями',
              '=додати', 'асинхронна', 'різниця', 'є несумісним?',
              'компілювати', 'старт', 'значення', 'є десятковим?', '=і',
              'форматування', 'рядкувати', 'містить', 'шістнадцятковий',
              '|бітове зміщення вправо', 'відсортований', 'зниження', 'об_єднання',
              'доповнити', 'зворотнє сортування', 'добавити', '=додавання',
              'встановити формат', 'текст', 'вставити', 'нижній реєстр',
              'округлення', 'виключити', 'є підкласом?', 'вивести в консоль',
              'менше дорівнює', 'очистити', '=множення', 'продовжити', 'форматувати',
              'розмір елемента', 'в ціле число', 'індекси', 'сортувати', 'з_єднати',
              'субофсети', 'унарне додавання', '|додавання', 'чисельник',
              'копіювати', 'множина', 'зріз', 'повертати', 'має атрибут?',
              'шифрувати', 'ділення', 'видалити елемент', 'суміжний',
              'видалити елемент', 'відкрити', 'з шістнадцяткового', 'Еліпсис', 'в',
              '|бітове зміщення вліво', 'фільтрувати', 'є алфавітним?', 'встановлення атрибута',
              'бітове зміщення вліво', 'словник', '|двійковий ксор', 'змінні', 'новий',
              'глобальні змінні', 'в список', 'видалити', 'з байтів', 'закінчується з?',
              'отримати атрибут', 'уявне', 'викликається?', 'округлити', 'дійсне',
              'встановити атрибут', 'заголовок', 'розмір', 'є ідентифікатором?',
              'не', 'кодувати', 'ввести з консолі', 'зміна реєстру', 'клас_',
              'і_', 'символ', 'розподіл', '__subclasshook__',
              'видалення атрибута', 'функція', 'форматувати перетворювач', 'біт довжина',
              'виконати', 'сформувати', 'віднімання', 'байти', 'відсортований зворотньо',
              'пропустити', 'є верхнім реєстром?', 'довжина', 'є аскдіо?', 'видалити за індексом', 'об_єкт',
              'якщо', 'локальні змінні', 'видалити з множини', 'комплексне число', 'метод класу',
              'встановити за замовчуванням', 'розкодувати', 'у байти', 'число',
              'інвертування', 'суміжний з сі?', 'з', 'масив з байтів',
              'шістнадцяткове в байти', 'є нижнім реєстром?', 'допомога', 'є цілим числом?',
              'оновити', 'ключі', 'більше?', 'модуль числа', 'сума', 'чекати',
              'Істина', 'піднесення до степеня', 'сортувати зворотньо', 'перетворювач', 'видалити символи з початку',
              'скинути',
              'і', 'є підмножиною?', 'вхід', 'стоп', 'не дорівнює',
              'каталог_', 'є?', 'ціле ділення та остача', 'видалити компонент', 'максимальне',
              'статичний метод', 'множення', 'з модуля', 'клас', 'замінити',
              'розподіл з кінця', 'розділити', 'отримання нових аргументів', 'імпортувати',
              'стиснути', 'в лише для читання', 'кроки', 'нелокальний',
              'хешування', 'перекласти', 'перервати', 'властивість',
              '|або', 'знайти з кінця', 'вирівняти з початку', '|ціле ділення та остача', 'хеш',
              'інакше', 'спробувати виконати', 'розділити з кінця', '=або',
              'оновити  різницю', 'індекс', 'заявити', 'супер',
              'табуляцію в пробіли', '__alloc__', 'всі істинні?', 'Хиба', 'дорівнює',
              'зменшення', 'бітове зміщення вправо', 'є істинний?', 'булева логіка',
              'верхній реєстр', 'отримання елементу', 'поки', 'негативне',
              'є виводоздатним?', 'додати в кінець', 'повернути', 'є екземпляром?',
              'або_', 'діапазон', 'як чисельник і знаменник', 'є пробілом?',
              'додавання', 'є титулом?', 'ціле число', 'є алфавітноцифровим?', 'видалити символи з кінця',
              'видалити символи', 'тип', 'ініціалізація', 'ініціалізація підкласу',
              'документація', 'розділити лінії', 'або', 'глобальний', 'якщо інакше', 'для змінної',
              'елементи', 'ітерування', '|множення', '|остача',
              '|піднесення до степеня', 'лише для читання', 'отримання формату', 'каталог',
              '|ділення', 'ксор', 'є числом?', '|віднімання',
              'ідентифікатор', 'вирівнювання вправо', 'число символу', 'ітерувати', 'перегляд пам_яті', 'більше рівне',
              'знайти', 'форма', 'стала множина', 'індексування', 'визначення довжини',
              'логічний', 'наступний', 'цілочисельне ділення', 'підрахувати', 'Ніщо',
              'встановити елемент', 'цілочисельно поділити', 'атрибути', 'точка зупину',
              'імпортування', 'екземпляр', 'вивести', 'очистити вивід', 'ввести',
              'вийти']

pykeywords_py: list = pykeywords.copy()
uakeywords_py: list = uakeywords.copy()


def is_double_brackets(txt: str) -> bool:
    txt: str = " " + txt + " "
    is_double_quote: bool = False
    is_single_quote: bool = False
    for i in range(len(txt)):
        if txt[i] == "'":
            if txt[i - 1] != "\\":
                is_single_quote = True
                break
        elif txt[i] == '"':
            if txt[i - 1] != "\\":
                is_double_quote = True
                break
    if not is_double_quote and not is_single_quote:
        return True
    else:
        count_quotes: int = 0
        last_ind: int = 0
        if is_single_quote:
            for j in range(i, len(txt)):
                if txt[j] == "'":
                    if txt[j - 1] != "\\":
                        count_quotes += 1
                        last_ind = j
            if count_quotes % 2 == 0:
                return is_double_brackets(txt[j+1:])
            else:
                return False

        else:
            for j in range(i, len(txt)):
                if txt[j] == "\"":
                    if txt[j - 1] != "\\":
                        count_quotes += 1
                        last_ind = j
            if count_quotes % 2 == 0:
                 return is_double_brackets(txt[j+1:])
            else:
                return False


def SortKeywords():
    global uakeywords, uakeywords_py, pykeywords_py
    ua_list: list = uakeywords.copy()
    py_list: list = pykeywords.copy()
    uakeywords = sorted(ua_list, reverse=True, key=len)
    pykeywords_py = sorted(py_list, reverse=True, key=len)
    for i in range(len(uakeywords)):
        pykeywords[i] = py_list[ua_list.index(uakeywords[i])]
    for i in range(len(uakeywords)):
        uakeywords_py[i] = ua_list[py_list.index(pykeywords_py[i])]


def is_alnum(char: str) -> bool:  # !!!!
    """Checks if there is char alnum or equal to '_'"""
    if char.isalnum():
        return True
    else:
        if char == "_":
            return True
        else:
            return False


def is_keyword(strline: str, keyword: str) -> bool:
    """Checks if there is a keyword"""
    strline = " " + strline + " "
    found: int = strline.find(keyword)
    if all((is_double_brackets(strline[:found]),
            not is_alnum(strline[found - 1]) and not is_alnum(strline[found + len(keyword)]))):
        return  True
    else:
        return False


def StrToLines(txt: str) -> list:
    """Converts text to lines divided by end of line"""
    lst: list = []
    li: int = 0
    isq1: bool = False  # is '''
    isq2: bool = False  # is """
    i = 0
    for i in range(len(txt)):
        if txt[i] == "\n":
            if not isq1 or not isq2:
                part: str = txt[li:i + 1]
                if "#" not in part:
                    if is_double_brackets(part):
                        li = i + 1
                        lst.append(part)
                else:
                    if is_double_brackets(part[:part.find("#")]):
                        li = i + 1
                        lst.append(part)
        elif txt[i] == "'":
            if txt[i + 1:i + 3] == "''":
                isq1 = not isq1
        elif txt[i] == '"':
            if txt[i + 1:i + 3] == '""':
                isq2 = not isq2
    else:
        lst.append(txt[li:i + 1])
    return lst


def UaWordToPy(word: str) -> str:
    try:
        return pykeywords[uakeywords.index(word)]
    except ValueError:
        return word


def PyWordToUa(word: str) -> str:
    try:
        return uakeywords_py[pykeywords_py.index(word)]
    except ValueError:
        return word


def UaToPy(txt: str) -> str:
    """Translates ukrainian script to python"""
    lines: list = StrToLines(txt)
    isq1: bool = False
    isq2: bool = False
    for i in range(len(lines)):
        line: str = lines[i]
        if "'''" in line:
            q1: int = line.find("'''")
            if line.find("#") != -1 and line.find("#") < q1:
                if line[:q1].count('"') % 2 == 0:
                    isq1 = not isq1
        elif '"""' in line:
            q2: int = line.find('"""')
            if line.find("#") != -1 and line.find("#") < q2:
                if line[:q2].count("'") % 2 == 0:
                    isq2 = not isq2
        cp: int = -1
        if not isq1 or not isq2:
            if "#" in line:
                if is_double_brackets(line[:line.find("#")]):
                    cp = line.find("#")
            line_part: str = line[:cp] if (cp != -1) else line
            for j in range(len(uakeywords)):
                if uakeywords[j] in line_part:
                    for y in range(line_part.count(uakeywords[j])):
                        if is_keyword(line_part, uakeywords[j]):
                            line = line.replace(uakeywords[j], pykeywords[j], 1)
            lines[i] = line
    return "".join(lines)


def PyToUa(txt: str) -> str:
    """Translates python script to 'ukrainian'"""
    lines: list = StrToLines(txt)
    isq1: bool = False
    isq2: bool = False
    for i in range(len(lines)):
        line: str = lines[i]
        if "'''" in line:
            q1: int = line.find("'''")
            if line.find("#") != -1 and line.find("#") < q1:
                if line[:q1].count('"') % 2 == 0:
                    isq1 = not isq1
        elif '"""' in line:
            q2: int = line.find('"""')
            if line.find("#") != -1 and line.find("#") < q2:
                if line[:q2].count("'") % 2 == 0:
                    isq2 = not isq2
        cp: int = -1
        if not isq1 or not isq2:
            if "#" in line:
                if is_double_brackets(line[:line.find("#")]):
                    cp = line.find("#")
            for j in range(len(pykeywords_py)):
                line_part: str = line[:cp] + " "
                if pykeywords_py[j] in line_part:
                    for y in range(line_part.count(pykeywords_py[j])):
                        if is_keyword(line_part, pykeywords_py[j]):
                            line = line.replace(pykeywords_py[j], uakeywords_py[j], 1)
            lines[i] = line
    return "".join(lines)


if __name__ == "__main__":
    SortKeywords()
    ls = """клас персона(об_єкт):
    функція ініціалізація(екземпляр, імя):
        екземпляр.імя = імя
        
Тарас = персона("Тарас")
вивести(текст(Тарас.імя))
"""
    # cin = input("=")
    # print(is_double_brackets(cin))
    ls = UaToPy(ls)
    print(ls)
    # print(UaToPy("ініціалізація"))
    # for i in range(len(uakeywords)):
    #     print(uakeywords[i], pykeywords[i])
    # print(pykeywords_py[i], uakeywords_py[i])
    # print(PyWordToUa('print'))
